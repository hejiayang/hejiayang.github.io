<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-29T13:06:11.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是ETag</title>
    <link href="http://yoursite.com/2017/12/29/%E4%BB%80%E4%B9%88%E6%98%AFETag/"/>
    <id>http://yoursite.com/2017/12/29/什么是ETag/</id>
    <published>2017-12-29T13:01:37.000Z</published>
    <updated>2017-12-29T13:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>ETag 是 Entity Tag 的缩写，中文译过来就是实体标签的意思。在HTTP1.1协议中其实就是请求HEAD中的一个属性而已。</p><p>HTTP/1.1 200 OK<br>Date: Mon, 23 May 2005 22:38:34 GMT<br>Content-Type: text/html; charset=UTF-8<br>Content-Encoding: UTF-8<br>Content-Length: 138<br>Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT<br>Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)<br>ETag: “3f80f-1b6-3e1cb03b”<br>Accept-Ranges: bytes<br>Connection: close</p><p><html></html></p><p><head><br>  <title>An Example Page</title><br></head></p><p><body><br>  Hello World, this is a very simple HTML document.<br></body><br><br>请注意第8行的 ETag: “3f80f-1b6-3e1cb03b”配置，那么为什么要用ETag呢？</p><p>ETag是HTTP1.1中才加入的一个属性，用来帮助服务器控制Web端的缓存验证。它的原理是这样的，当浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值(3f80f-1b6-3e1cb03b)并通过 ETag 返回给浏览器，浏览器把”3f80f-1b6-3e1cb03b” 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 If-None-Match: “3f80f-1b6-3e1cb03b” 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一个304未修改。这样通过控制浏览器端的缓存，可以节省服务器的带宽，因为服务器不需要每次都把全量数据返回给客户端。</p><p>注：HTTP中并没有指定如何生成ETag，哈希是比较理想的选择。</p><p>作者：ntop<br>链接：<a href="https://www.jianshu.com/p/a3ea9619c38d" target="_blank" rel="external">https://www.jianshu.com/p/a3ea9619c38d</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ETag 是 Entity Tag 的缩写，中文译过来就是实体标签的意思。在HTTP1.1协议中其实就是请求HEAD中的一个属性而已。&lt;/p&gt;
&lt;p&gt;HTTP/1.1 200 OK&lt;br&gt;Date: Mon, 23 May 2005 22:38:34 GMT&lt;br&gt;Cont
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx 如何解析一个请求</title>
    <link href="http://yoursite.com/2017/11/11/nginx-%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2017/11/11/nginx-如何解析一个请求/</id>
    <published>2017-11-11T03:18:53.000Z</published>
    <updated>2017-11-11T03:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>会用到的概念：</p><p>默认虚拟主机：在多个server的情况下，被设置了default_server监听端口属性的server为默认虚拟主机（v0.8.21前监听端口属性的关键字为default） ，如果没有被设置的主机，则第一个server为默认虚拟主机。</p><p>server {<br>    listen      80 default_server;<br>    server_name example.net www.example.net;<br>    …<br>}</p><p>首先会用到nginx的配置文件 nginx.conf</p><p>首先根据host找到指定server，如果没有host或没有找到指定的server，</p><p>就会找到默认的虚拟主机。</p><p>如果不允许请求中缺失host头可以定义如下主机，丢弃这些请求</p><p>server {<br>    listen       80;<br>    server_name  “”;<br>    return       444;<br>}<br>可以设置主机名为空来匹配缺失host头的请求，而且返回了一个nginx特有的，非http标准的返回码4444，可以关闭连接。</p><p>从0.8.48版本开始，这已成为主机名的默认设置，所以可以省略server_name “”。而之前的版本使用机器的hostname作为主机名的默认值</p><p>下面让我们来看一个复杂点的配置，在这个配置里，有几个虚拟主机在不同的地址上监听：</p><p>server {<br>    listen      192.168.1.1:80;<br>    server_name example.org www.example.org;<br>    …<br>}</p><p>server {<br>    listen      192.168.1.1:80;<br>    server_name example.net www.example.net;<br>    …<br>}</p><p>server {<br>    listen      192.168.1.2:80;<br>    server_name example.com www.example.com;<br>    …<br>}<br>这个配置中，nginx首先测试请求的IP地址和端口是否匹配某个server配置块中的listen指令配置。接着nginx继续测试请求的Host头是否匹配这个server块中的某个server_name的值。如果主机名没有找到，nginx将把这个请求交给默认虚拟主机处理。例如，一个从192.168.1.1:80端口收到的访问www.example.com的请求将被监听192.168.1.1:80端口的默认虚拟主机处理，本例中就是第一个服务器，因为这个端口上没有定义名为www.example.com的虚拟主机。</p><p>默认服务器是监听端口的属性，所以不同的监听端口可以设置不同的默认服务器：</p><p>server {<br>    listen      192.168.1.1:80;<br>    server_name example.org www.example.org;<br>    …<br>}</p><p>server {<br>    listen      192.168.1.1:80 default_server;<br>    server_name example.net www.example.net;<br>    …<br>}</p><p>server {<br>    listen      192.168.1.2:80 default_server;<br>    server_name example.com www.example.com;<br>    …<br>}</p><p>现在我们来看在一个典型的，简单的PHP站点中，nginx怎样为一个请求选择location来处理：</p><p>server {<br>    listen      80;<br>    server_name example.org www.example.org;<br>    root        /data/www;</p><pre><code>location / {    index   index.html index.php;}location ~* \.(gif|jpg|png)$ {    expires 30d;}location ~ \.php$ {    fastcgi_pass  localhost:9000;    fastcgi_param SCRIPT_FILENAME                  $document_root$fastcgi_script_name; // host:192.0.0.1/index.php   /data/www/index.php  $document_root = /data/www , $fastcgi_script_name = /index.php    include       fastcgi_params;}</code></pre><p>}<br>首先，nginx使用前缀匹配找出最准确的location，这一步nginx会忽略location在配置文件出现的顺序。上面的配置中，唯一的前缀匹配location是”/“，而且因为它可以匹配任意的请求，所以被作为最后一个选择。接着，nginx继续按照配置中的顺序依次匹配正则表达式的location，匹配到第一个正则表达式后停止搜索。匹配到的location将被使用。如果没有匹配到正则表达式的location，则使用刚刚找到的最准确的前缀匹配的location。</p><p>请注意所有location匹配测试只使用请求的URI部分，而不使用参数部分。这是因为写参数的方法很多，比如：</p><p>/index.php?user=john&amp;page=1<br>/index.php?page=1&amp;user=john<br>除此以外，任何人在请求串中都可以随意添加字符串：</p><p>/index.php?page=1&amp;something+else&amp;user=john<br>现在让我们来看使用上面的配置，请求是怎样被处理的：</p><p>请求”/logo.gif”首先匹配上location “/“，然后匹配上正则表达式”.(gif|jpg|png)$”。因此，它将被后者处理。根据”root /data/www”指令，nginx将请求映射到文件/data/www/logo.gif”，并发送这个文件到客户端。<br>请求”/index.php”首先也匹配上location “/“，然后匹配上正则表达式”.(php)$”。 因此，它将被后者处理，进而被发送到监听在localhost:9000的FastCGI服务器。fastcgi_param指令将FastCGI的参数SCRIPT_FILENAME的值设置为”/data/www/index.php”，接着FastCGI服务器执行这个文件。变量$document_root等于root指令设置的值，变量$fastcgi_script_name的值是请求的uri，”/index.php”。<br>请求”/about.html”仅能匹配上location “/“，因此，它将使用此location进行处理。根据”root /data/www”指令，nginx将请求映射到文件”/data/www/about.html”，并发送这个文件到客户端。<br>请求”/“的处理更为复杂。它仅能匹配上location “/“，因此，它将使用此location进行处理。然后，index指令使用它的参数和”root /data/www”指令所组成的文件路径来检测对应的文件是否存在。如果文件/data/www/index.html不存在，而/data/www/index.php存在，此指令将执行一次内部重定向到”/index.php”，接着nginx将重新寻找匹配”/index.php”的location，就好像这次请求是从客户端发过来一样。正如我们之前看到的那样，这个重定向的请求最终交给FastCGI服务器来处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;会用到的概念：&lt;/p&gt;
&lt;p&gt;默认虚拟主机：在多个server的情况下，被设置了default_server监听端口属性的server为默认虚拟主机（v0.8.21前监听端口属性的关键字为default） ，如果没有被设置的主机，则第一个server为默认虚拟主机。&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>安装nginx的一些参数</title>
    <link href="http://yoursite.com/2017/11/10/%E5%AE%89%E8%A3%85nginx%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2017/11/10/安装nginx的一些参数/</id>
    <published>2017-11-10T03:27:53.000Z</published>
    <updated>2017-11-10T03:32:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>configure命令用来配置nginx编译环境。 该命令定义了系统各方面功能，包括允许nginx使用的连接处理方式。 其执行结果是生成一个Makefile文件。 configure命令支持如下参数：</p><p>–prefix=path — 定义服务器文件的完整路径，该路径同时也是configure命令设置的 相对路径（除类库源文件外）以及nginx.conf文件定义的相对路径的基准路径。其默认 值是/usr/local/nginx。</p><p>–sbin-path=path — 设置nginx可执行文件的完整路径，该路径仅在安装期间使用， 默认路径为prefix/sbin/nginx。</p><p>–conf-path=path — 设置配置文件nginx.conf的完整路径。如有必要，总是可以 在nginx启动时通过命令行参数-cfile指定一个不同的配置文件路径。 默认路径为prefix/conf/nginx.conf。</p><p>–pid-path=path — 设置nginx.pid文件的完整路径，该文件存储了主进程的进程ID。安装完成后， 该路径总是可以在nginx.conf文件中用 pid指令来修改。 默认路径为prefix/logs/nginx.pid。</p><p>–error-log-path=path — 设置记录主要错误、警告以及调试信息日志的完整路径。安装完成后， 该路径总是可以在nginx.conf文件中用 error_log 指令来修改。 默认路径为prefix/logs/error.log。</p><p>–http-log-path=path — 设置记录HTTP服务器主要请求日志的完整路径。安装完成后， 该路径总是可以在nginx.conf文件用 access_log 指令来修改。 默认路径为prefix/logs/access.log</p><p>–user=name — 设置工作进程以某非特权用户的身份运行。安装完成后，该用户名总是可以在 nginx.conf文件用user指令来修改。 其默认值为nobody。</p><p>–group=name — 设置工作进程以某非特权用户的身份运行。安装完成后，该用户名总是可以在 nginx.conf用user指令来修改。 其默认名称与未授权用户名称相同。</p><p>–with-select_module<br>–without-select_module — 设置是否将select()方法模块编译进nginx中。如果系统平台不支持kqueue、epoll、rtsig或/dev/poll等更合适的方法， 该模块会被自动编译。</p><p>–with-poll_module<br>–without-poll_module — 设置是否将poll()方法模块编译进nginx中。如果系统平台不支持kqueue、epoll、rtsig或/dev/poll等更合适的方法， 该模块会被自动编译。</p><p>–without-http_gzip_module — 不编译http_gzip_module模块。该模块可以压缩HTTP服务器的响应，该模块需要zlib库才能编译和运行。</p><p>–without-http_rewrite_module — 不编译http_rewrite_module模块。该模块允许HTTP服务器重定向请求，改变请求的URI地址 。创建并运行该模块需要PCRE库支持。</p><p>–without-http_proxy_module — 不编译HTTP服务器的代理模块。</p><p>–with-http_ssl_module — 为HTTP服务器编译HTTPS协议支持的模块。该模块默认是不编译的。它需要OpenSSL库才能编译和运行。</p><p>–with-pcre=path — 设置PCRE库源文件的路径地址。PCRE库的发行版(version 4.4 — 8.30)需要先从PCRE站点下载并解压缩。 剩下的安装工作由nginx的./configure和make命令来完成。该库应用于location 指令的正则表达式支持以及ngx_http_rewrite_module模块。</p><p>–with-pcre-jit — 编译PCRE库时增加“实时编译（pcre_jit）”支持。</p><p>–with-zlib=path — 设置zlib库源文件的路径地址。zlib库的发行版(version 1.1.3 — 1.2.5)需要先从zlib站点下载并解压缩。 剩下的安装工作由nginx的./configure和make命令来完成。该库应用于 ngx_http_gzip_module模块。</p><p>–with-cc-opt=parameters — 设置将会添加额外参数到CFLAGS变量中。当在FreeBSD使用系统PCRE库时，需要指定 –with-cc-opt=”-I /usr/local/include”。 如果需要增加select()方法所支持的文件数量，也可以参照如下方式指定： –with-cc-opt=”-D FD_SETSIZE=2048”。</p><p>–with-ld-opt=parameters — 设置将会在链接（linking）过程中使用的额外参数。当在FreeBSD使用系统PCRE库时，需要指定 –with-ld-opt=”-L /usr/local/lib”。</p><p>以下是参数使用示例（注意不应有换行）：</p><p>./configure<br>    –sbin-path=/usr/local/nginx/nginx<br>    –conf-path=/usr/local/nginx/nginx.conf<br>    –pid-path=/usr/local/nginx/nginx.pid<br>    –with-http_ssl_module<br>    –with-pcre=../pcre-4.4<br>    –with-zlib=../zlib-1.1.3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;configure命令用来配置nginx编译环境。 该命令定义了系统各方面功能，包括允许nginx使用的连接处理方式。 其执行结果是生成一个Makefile文件。 configure命令支持如下参数：&lt;/p&gt;
&lt;p&gt;–prefix=path — 定义服务器文件的完整路径，该
      
    
    </summary>
    
    
  </entry>
  
</feed>
